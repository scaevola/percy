<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Percy - Isomorphic Web Apps in Rust</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li><a href="views/index.html"><strong aria-hidden="true">1.</strong> Rendering Views</a></li><li><ol class="section"><li><a href="virtual-dom/index.html"><strong aria-hidden="true">1.1.</strong> Virtual DOM</a></li><li><ol class="section"><li><a href="virtual-dom/html-macro.html"><strong aria-hidden="true">1.1.1.</strong> Writing html!</a></li><li><a href="virtual-dom/unit-testing-views.html"><strong aria-hidden="true">1.1.2.</strong> Unit Testing your Views</a></li></ol></li><li><a href="views/server-side-rendering/index.html"><strong aria-hidden="true">1.2.</strong> Server Side Rendering (SSR)</a></li><li><ol class="section"><li><a href="views/server-side-rendering/why-ssr.html"><strong aria-hidden="true">1.2.1.</strong> Why SSR</a></li><li><a href="views/server-side-rendering/how-to-ssr.html"><strong aria-hidden="true">1.2.2.</strong> How to SSR</a></li></ol></li></ol></li><li><a href="router/index.html"><strong aria-hidden="true">2.</strong> Router</a></li><li><a href="css-in-rust.html"><strong aria-hidden="true">3.</strong> CSS in Rust</a></li><li><a href="contributing/index.html"><strong aria-hidden="true">4.</strong> Contributing</a></li><li><ol class="section"><li><a href="contributing/getting-started.html"><strong aria-hidden="true">4.1.</strong> Getting Started</a></li><li><a href="contributing/ways-to-contribute.html"><strong aria-hidden="true">4.2.</strong> Types of Contributions</a></li><li><a href="contributing/internal-design/index.html"><strong aria-hidden="true">4.3.</strong> Internal Design</a></li><li><ol class="section"><li><a href="contributing/internal-design/sibling-text-nodes.html"><strong aria-hidden="true">4.3.1.</strong> Handling text siblings</a></li></ol></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Percy - Isomorphic Web Apps in Rust</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p><code>Percy</code> is a modular toolkit for building isomorphic web apps with Rust + WebAssembly.</p>
<p>Modular in the sense that a big design focus is being able to replace different
parts of the <code>Percy</code> toolkit with third party implementation that better suit your needs.</p>
<p>Isomorphic in the sense that it has out of the box support for server side rendering
of your single page applications.</p>
<p><code>Percy</code> is not yet ready for production (unless you're incredibly brave), but if you're
interested in using it for real things you can <a href="https://github.com/chinedufn/percy/watchers">watch the development progress.</a>.</p>
<a class="header" href="#a-snippet" id="a-snippet"><h3>A snippet</h3></a>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate virtual_dom_rs;

// Percy supports events, classes, attributes a virtual dom
// with diff/patch and everything else that you'd expect from
// a frontend toolkit.
//
// This, however, is just the most basic example of rendering
// some HTML on the server side.
fn main () {
  let some_component = html! {
    &lt;div class=&quot;cool-component&quot;,&gt;{ &quot;Hello World&quot; }&lt;/div&gt;
  };

  let html_string = some_component.to_string();
  println!(&quot;{}&quot;, html_string);
}
</code></pre></pre>
<a class="header" href="#roadmap" id="roadmap"><h3>Roadmap</h3></a>
<p><code>Percy</code> is very young and going through the early stages of development. Our roadmap is
is mainly led by Real World Driven Development.</p>
<p>This means that we're using <code>Percy</code> to build a real, production web app and ironing out
the kinks and fixing the bugs as we go.</p>
<p>Once the tools have stabilized and we've settled into a clean structure for <code>Percy</code>
applications we'll publish a CLI for generating a production-grade starter project with
everything that you need to get up and running.</p>
<p>Check out the <a href="https://github.com/chinedufn/percy/issues">Percy issue tracker</a> and
maybe open a couple of your own!</p>
<a class="header" href="#notable-features" id="notable-features"><h3>Notable Features</h3></a>
<p><code>Percy</code> is still young, so the feature set is still growing and maturing. At the moment:</p>
<ul>
<li>
<p>An <code>html!</code> macro that generates a virtual dom that can can be rendered into a DOM element
on the frontend or a <code>String</code> on the backend.</p>
</li>
<li>
<p>CSS in Rust - Optionally writing your CSS styles right next to your <code>html!</code> components instead
of in separate CSS/Sass/etc files.</p>
</li>
</ul>
<a class="header" href="#rendering-views" id="rendering-views"><h1>Rendering Views</h1></a>
<p>Almost all front-end web applications seek to display some (often times interactive)
content to a user.</p>
<p>This section will dive into how to render content with <code>Percy</code>.</p>
<a class="header" href="#virtual-dom" id="virtual-dom"><h1>Virtual DOM</h1></a>
<p>At the heart of the <code>Percy</code> toolkit is <code>virtual-dom-rs</code>, a crate that provides a virtual dom
implementation that allows you to write functional front-end applications.</p>
<p>This same <code>virtual-dom-rs</code> also works on the backend by rendering to a String instead of a DOM element.
This ability to render on the backend is commonly referred to as server side rendering.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate virtual_dom_rs;

// The most basic example of rendering to a String
fn main () {
  let component = html! { &lt;div&gt; {&quot;Hello world&quot;} &lt;/div&gt; };
  println!(&quot;{}&quot;, component);
  // &lt;div&gt;Hello world&lt;/div&gt;
}
</code></pre></pre>
<a class="header" href="#writing-html" id="writing-html"><h1>Writing html!</h1></a>
<a class="header" href="#text" id="text"><h3>Text</h3></a>
<p>Text is rendered inside of a block <code>{}</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let view = html!{
  &lt;div&gt; {&quot;Text goes here,&quot;} {&quot;or here&quot; &quot; or here!&quot;}&lt;/div&gt;
};
#}</code></pre></pre>
<a class="header" href="#attributes" id="attributes"><h3>Attributes</h3></a>
<p>At this time attributes must end with a <code>,</code> due to how our <code>html!</code> macro works.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let view = html!{
  &lt;div id='my-id',&gt;&lt;/div&gt;
};
#}</code></pre></pre>
<p>Event Handlers</p>
<p>Event handlers begin with a <code>!</code> and, like attributes must end with a <code>,</code>.</p>
<p>Percy will attach event handlers your DOM nodes via <code>addEventListener</code></p>
<p>So <code>!mycustomevent</code> becomes <code>element.addEventListener('mycustomevent', callback)</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn render (state: Rc&lt;State&gt;) -&gt; VirtualNode {
  let state = Rc::clone(&amp;self.state);

  let view = html! {
      &lt;button
        !onclick=move|_event: web_sys::MouseEvent| {
          state.borrow_mut().msg(Msg::ShowAlert)
        },&gt;
        { &quot;Dispatch 'mycustomevent' to me and I will do something!&quot; }
     &lt;/button&gt;
  };

  view
}
#}</code></pre></pre>
<a class="header" href="#nested-components" id="nested-components"><h3>Nested components</h3></a>
<p><code>html!</code> calls can be nested.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let view1 = html!{ &lt;em&gt; &lt;/em&gt; };
let view2 = html{ &lt;span&gt; &lt;/span&gt; }

let parent_view = html! {
  &lt;div&gt;
    { view1 }
    { view2 }
    html! {
      {&quot;Nested html! call&quot;}
    }
  &lt;/div&gt;
};


let html_string = parent_view.to_string();
// Here's what the String looks like:
// &lt;div&gt;&lt;em&gt;&lt;/em&gt;&lt;span&gt;&lt;/span&gt;Nested html! call&lt;/div&gt;
#}</code></pre></pre>
<a class="header" href="#unit-testing-your-views" id="unit-testing-your-views"><h1>Unit Testing your Views</h1></a>
<p>Percy's testing story is very much a work in progress, so please give feedback as you write tests!</p>
<p>Here's an example of unit testing your views. You can find it in the examples directory at <a href="https://github.com/chinedufn/percy/tree/master/examples/unit-testing-views">examples/unit-testing-views</a>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate virtual_dom_rs;

use virtual_dom_rs::VirtualNode;

fn main() {
    println!(&quot;To see this example in action:&quot;);
    println!(&quot;cargo test -p unit-testing-components&quot;);
}

#[allow(unused)]
fn full_water_bottle() -&gt; VirtualNode {
    html! {
    &lt;div&gt;
        &lt;span label=&quot;full-water&quot;,&gt;
          { &quot;I am full of delicious and refreshing H20!&quot; }
        &lt;/span&gt;
    &lt;/div&gt;
    }
}

#[allow(unused)]
fn struggling_water_bottle(percent_full: f32) -&gt; VirtualNode {
    let message = format!(
        &quot;Please fill me up :( I am only {} percent full :(&quot;,
        percent_full
    );

    html! {
        &lt;div label=&quot;struggle-water&quot;,&gt;
         { message }
        &lt;/div&gt;
    }
}


#[allow(unused)]
fn water_bottle_view(percent_full: f32) -&gt; VirtualNode {
    if percent_full &gt; 0.5 {
        full_water_bottle()
    } else {
        struggling_water_bottle(percent_full)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn conditional_water_messaging() {
        assert_eq!(
            water_bottle_view(0.7)
                .filter_label_equals(&quot;full-water&quot;)
                .len(),
            1
        );

        let water_view = water_bottle_view(0.2587);

        assert_eq!(
            water_view.children.as_ref().unwrap()[0]
                .text
                .as_ref()
                .unwrap(),
            &quot;Please fill me up :( I am only 0.2587 percent full :(&quot;
        )
    }
}

</code></pre></pre>
<a class="header" href="#server-side-rendering" id="server-side-rendering"><h1>Server Side Rendering</h1></a>
<p>This section outlines Percy's server side rendering support.</p>
<a class="header" href="#why-use-server-side-rendering" id="why-use-server-side-rendering"><h1>Why use Server Side Rendering</h1></a>
<p>In recent years it has become popular for just about all of a web application to be rendered on the client.</p>
<p>Applications will often serve almost nothing but a <code>&lt;script&gt;</code> tag that loads up some front-end code (<code>JavaScript</code> and/or <code>WebAssembly</code>)
and that front-end code is responsible for rendering the application's <code>HTML</code> and interactions.</p>
<p>Here's an example of what many of today's web application boil down to:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;!-- application will render HTML here when it begins --&gt;
  &lt;/div&gt;
  &lt;!--
    One this applications loads it will
    inject some HTML into the body
  --&gt;
  &lt;script src=&quot;/my-application.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<hr />
<p>One downside to this approach is that a user must wait until the script begins rendering before seeing anything.</p>
<p>Let's illustrate:</p>
<pre><code>Client side rendeiring
without server side rendering:

┌─────────────────────────────────────┐
│   1) Client requests for web page   │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│2) Server responds with &lt;script&gt; tag │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│     3) Client downloads script      │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│4) Client parses the returned script │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│ 5) Client executes returned script  │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐  User first
│ 6) Script starts rendering content  │◀─   sees
└─────────────────────────────────────┘   content
</code></pre>
<p>Contrast this with server side rendering, where the initial page load might look something like this:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
  &lt;!--
    This content was sent down from the server so
    that the user sees something immediately!
  --&gt;
  &lt;/div&gt;

  &lt;script src=&quot;/my-application.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>And the flow:</p>
<pre><code>Server side rendering then client
takes over rendering:

┌─────────────────────────────────────┐
│   1) Client requests for web page   │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│   2) Server responds with server    │  User first
│ side rendered content along with a  │◀─   sees
│            &lt;script&gt; tag             │   content
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│     3) Client downloads script      │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│4) Client parses the returned script │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│ 5) Client executes returned script  │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│ 6) Script starts rendering content  │
└─────────────────────────────────────┘
</code></pre>
<p>Server side rendering allows you to some <em>something</em> to your users more quickly,
especially so for users with slower machines and/or bandwidth.</p>
<a class="header" href="#how-to-ssr" id="how-to-ssr"><h1>How to SSR</h1></a>
<p>In the most simple case, server side rendering in <code>Percy</code> boils down to
rendering your virtual DOM to a <code>String</code> and responding to a client with
that <code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate virtual_dom_rs;
use std::cell::Cell;

fn main () {
  let count_cell = Cell::new(5);

  let app = html! {
    &lt;div id='app',&gt;
      &lt;button !onclick=|_ev| { *count+= 1; },&gt;
        { &quot;Hello world&quot; }
      &lt;/button&gt;
    &lt;/div&gt;
  };


  let html_to_serve = app.to_string();
  // &lt;div id='app'&gt;&lt;button&gt;Hello world&lt;/button&gt;&lt;/div&gt;

  // .. server string to client (http response) ...
}
</code></pre></pre>
<a class="header" href="#hydrating-initial-state" id="hydrating-initial-state"><h2>Hydrating initial state</h2></a>
<p>You'll usually want your views to be rendered based on some application state. So, typically, your server will</p>
<ol>
<li>Receive a request from the client</li>
<li>Set the initial application state based on the request</li>
<li>Render the application using the initial state</li>
<li>Reply with the initial HTML and the initial state</li>
<li>Client takes over rendering, starting from the initial state.</li>
</ol>
<p>To illustrate we'll take a look at an excerpt from a more realistic server side rendering example.</p>
<p>Afterwards you can check out the full example at <a href="https://github.com/chinedufn/percy/tree/master/examples/isomorphic">examples/isormorphic</a>.</p>
<hr />
<p>A more realistic server side rendering implementation would look like the following:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;app.css&quot;/&gt;
    &lt;title&gt;Rust Web App&lt;/title&gt;
&lt;/head&gt;
&lt;body style='margin: 0; padding: 0; width: 100%; height: 100%;'&gt;
  &lt;div id=&quot;isomorphic-rust-web-app&quot; style='width: 100%; height: 100%;'&gt;
      #HTML_INSERTED_HERE_BY_SERVER#
  &lt;/div&gt;

  &lt;script&gt;
    window.GlobalJS = function () {}
    window.GlobalJS.prototype.update = function () {
      window.update()
    }
  &lt;/script&gt;
  &lt;script src='./isomorphic_client.js'&gt;&lt;/script&gt;
  &lt;script&gt;window.initialState = '#INITIAL_STATE_JSON#'&lt;/script&gt;
  &lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// examples/isormorphic/server/src/server.rs
// Check out the full application in /examples/isormorphic directory
extern crate actix_web;
use self::actix_web::{fs, HttpRequest, HttpResponse, Responder};

extern crate listenfd;
use self::listenfd::ListenFd;

use isomorphic_app::App;

const HTML_PLACEHOLDER: &amp;str = &quot;#HTML_INSERTED_HERE_BY_SERVER#&quot;;
const STATE_PLACEHOLDER: &amp;str = &quot;#INITIAL_STATE_JSON#&quot;;

fn index(req: &amp;HttpRequest) -&gt; impl Responder {
    let app = App::new(
        req.query()
            .get(&quot;init&quot;)
            .map(|string| string.parse().expect(&quot;bad param&quot;))
            .unwrap_or(1001),
    );
    let state = app.store.borrow();

    let html = format!(&quot;{}&quot;, include_str!(&quot;./index.html&quot;));
    let html = html.replacen(HTML_PLACEHOLDER, &amp;app.render().to_string(), 1);
    let html = html.replacen(STATE_PLACEHOLDER, &amp;state.to_json(), 1);

    HttpResponse::Ok().content_type(&quot;text/html&quot;).body(html)
}

pub fn serve() {
    let mut listenfd = ListenFd::from_env();

    let server = actix_web::server::new(|| {
        let app = actix_web::App::new();
        let app = app.resource(&quot;/&quot;, |r| r.f(index));
        let app = app.handler(&quot;/&quot;, fs::StaticFiles::new(&quot;./build&quot;).unwrap());
        let app = app.handler(&quot;/&quot;, fs::StaticFiles::new(&quot;./dist&quot;).unwrap());
        app
    });

    let server = if let Some(l) = listenfd.take_tcp_listener(0).unwrap() {
        server.listen(l)
    } else {
        server.bind(&quot;0.0.0.0:7878&quot;).unwrap()
    };

    println!(&quot;Listening on port 7878&quot;);
    server.run();
}

#}</code></pre></pre>
<p>And then the client would use <code>serde</code> to deserialize the <code>initialState</code>
into a State struct and begin rendering using that State.</p>
<a class="header" href="#router" id="router"><h1>Router</h1></a>
<p>We're working on tooling for view routing. Here's a preview of how it could look:</p>
<p>(Note that we're still thinking through the API so this is just a rough draft)</p>
<p>In the meantime definitely share your thoughts in the <a href="https://github.com/chinedufn/percy/issues/28">Router tracking issue!</a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate virtual_dom_rs;

extern crate router_rs;
extern crate router_rs_macro;

use virtual_dom_rs::View;

use router_rs::{ViewRouter, Transition};
use router_rs_macro::router;

struct App {
    store: Rc&lt;Store&gt;,
}

struct Store {
    state: RefCell&lt;State&gt;
    vutils: ViewUtils,
    router: ViewRouter
}

impl Store {
    // ... still thinking ...
}

impl App {
    pub fn new () -&gt; App {
        let mut router = ViewRouter::new();
        router
          .add_route(HomePage)
          .add_route(AuthorPage)
          .add_route(EditPostPage)
          .not_found(FourOhFourPage);
        let router = Rc::new(router);

        App {
            store: Store::new(router, vutils),
            vutils: ViewUtils::new(Rc::clone(&amp;router)),
            router
        }
    }
}

#[route(path = &quot;/&quot;)]
struct HomePage;

impl View for HomePage {
    fn render(
        &amp;self,
        store: Rc&lt;Store&gt;,
    ) -&gt; VirtualNode {
        html! {
            &lt;div id='homepage',&gt;
                &lt;button !onclick |_ev| {
                    store.msg(Msg::Route(&quot;/posts/25/authors/jennifer&quot;));
                },&gt;
                    { &quot;Get the behind the scenes on how&quot; }
                    { &quot; jenny helped write the latest post!&quot; }
                &lt;/button&gt;
            &lt;/div&gt;
        }
    }
}

#[route(path = &quot;/posts/{post_id}/authors/{name}&quot;)]
struct AuthorPage {
  post_id: u32,
  name: String
};

impl View for AuthorPage {
  fn render (
      &amp;self,
      store: Rc&lt;Store&gt;,
  ) -&gt; VirtualNode {
      match state.get_post(self.post_id()).get_author(&amp;self.name()) {
          Some(ref author) =&gt; {
              html! {
                  { format!(&quot;Info about {}&quot;, author.name) }
              }
          }
          None =&gt; &quot;Author does not exist&quot;
      }
  }
}

struct IsAdmin;

impl BeforeEnteringRoute for IsAdmin {
    fn before_route (state: &amp;State) -&gt; Transition {
        if state.is_admin() {
            Transition::Continue
        } else {
            Transition::Redirect(&quot;/login&quot;)
        }
    }
}

#[route(path = &quot;/posts/{post_id/edit&quot;, before = IsAdmin)]
struct EditPostPage {
    post_id: u32,
};

impl View for EditPostPage {
  fn render (
      &amp;self,
      store: Rc&lt;Store&gt;,
  ) -&gt; VirtualNode {
    html! { &lt;div&gt; { format!(&quot;Editing post {}&quot;, self.post_id())} &lt;/div&gt; }
  }
}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">fn main () {
  let mut router = Router::new();

  let mut params = HashMap::new();
  params.insert(&quot;param1&quot;, ParamType::U32);
  params.insert(&quot;param2&quot;, ParamType::String);

  router.add_route(
      Route {
        path: &quot;/endpoint/:param1/info/:param2&quot;,
        params,
        view_creator: |params| {
          let param1 = params.get(&quot;...&quot;) as u32;
          let param2 = ...;
          MyPage::from_params(param1, param2)
        }
      }
  );

  router.set_route('/');
  let view = router.create_view();
  let view = view.render(Rc::clone(store));
}

struct Router {
  routes: Vec&lt;Route&gt;
}

struct Route&lt;'a&gt; {
  // /path/:param1/info/:another_param
  path: &amp;'a str,
  params: HashMap&lt;String, ParamType&gt;
  view_creator: Fn(HashMap&lt;String, Param&gt;) -&gt; impl View
}

impl Router {
  fn change_to('/') -&gt; VirtualNode
}

struct MyPage {
  param1: u32,
  param2: String
}

impl MyPage {
  fn from_params(param1: u32, param2: String) {
    MyPage { param1, param2 }
  }
}
</code></pre></pre>
<a class="header" href="#css-in-rust" id="css-in-rust"><h1>CSS in Rust</h1></a>
<a class="header" href="#contributing" id="contributing"><h1>Contributing</h1></a>
<p>This section is meant to help you get up to speed with how you can contribute to the <code>Percy</code> project.</p>
<a class="header" href="#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<ol>
<li>
<p>Rust Nightly.</p>
<pre><code class="language-sh">rustup default nightly
rustup target add wasm32-unknown-unknown
</code></pre>
</li>
<li>
<p><a href="https://github.com/mozilla/geckodriver/releases">Install Geckodriver</a> since some of our tests are meant to run in a browser.
Put it somewhere in your path, i.e. you might move it to <code>/usr/local/bin/geckdriver</code>.</p>
</li>
<li>
<p>Download the project and make sure that you can run the test suite</p>
<pre><code class="language-sh">git clone https://github.com/chinedufn/percy
cd percy
./test.sh
</code></pre>
</li>
</ol>
<a class="header" href="#types-of-contributions" id="types-of-contributions"><h1>Types of Contributions</h1></a>
<p>There are three main types of contributions to <code>Percy</code>, all of which are equally important.</p>
<a class="header" href="#documentation--book-contributions--examples" id="documentation--book-contributions--examples"><h3>Documentation / Book Contributions / Examples</h3></a>
<p>Our documentation is the first thing that anyone interested in using <code>Percy</code> will see.
Before installing the tools, running the examples or starting up their own project they'll
peruse the documentation to get a sense of <code>Percy</code>'s design and how to get started.</p>
<p>Because of this, documentation and book contributions are incredibly useful and important.</p>
<p>While it's common for projects to dismiss typo fixes as unimportant contributions, we feel
the complete opposite. We strive for getting as close to &quot;perfect documentation&quot; as possible,
and anything that brings us a step closer matters.</p>
<a class="header" href="#documentation" id="documentation"><h5>Documentation</h5></a>
<p>Scroll around the codebase. If you don't instantly understand something then it is poorly
documented. Open up an issue or PR with your ideas on how it can be better communicated.</p>
<a class="header" href="#book-contributions" id="book-contributions"><h5>Book Contributions</h5></a>
<p>If there's a section that you think is missing from the book, PR the title of that section
with some placeholder text.</p>
<p>We're totally fine with not having book contributions fully fleshed out right away!</p>
<p>Having a placeholder makes it easy for yourself or someone else to feel motivated one day
and start hitting the keyboard.</p>
<pre><code class="language-sh"># To view the book locally as you edit
cd book &amp;&amp; mdbook serve --open
</code></pre>
<a class="header" href="#examples" id="examples"><h5>Examples</h5></a>
<p>If you can't figure out how exactly to implement something within 5 minutes that might mean
that you were underserved by the <code>examples</code> directory.</p>
<p>Open up an issue with your question or an idea with how to craft an example that would have
answered it!</p>
<a class="header" href="#building-something-with-percy" id="building-something-with-percy"><h3>Building Something with Percy</h3></a>
<p>When you're building a real application you run into problems, trade-offs and considerations
that you never could have thought of up front.</p>
<p>We want to uncover those problems and either address them in the main toolkit or point
people in the right direction for how to solve them in user land.</p>
<p>The more people that are using <code>Percy</code> to build things, the more of these problems we can
fix and/or suggest approaches for.</p>
<p>If you have an idea for something that you can build with <code>Percy</code> then get started. Feel
free to open up an issue with any questions or thoughts that you might have. Also open
issues / PRs as you run into problems / annoyances.</p>
<a class="header" href="#design-of-percy" id="design-of-percy"><h1>Design of <code>percy</code></h1></a>
<p>This section is intended to be a deep dive into how <code>percy</code>'s different internal pieces work today.</p>
<a class="header" href="#sibling-text-nodes" id="sibling-text-nodes"><h1>Sibling text nodes</h1></a>
<p>If you render two text nodes next to them the browser will see them as just
one text node.</p>
<p>For example, when you have a component that looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let sibling_text_nodes = html! { &lt;div&gt; {&quot;Hello&quot; &quot;World&quot; } &lt;/div&gt; };
#}</code></pre></pre>
<p>A browser will end up with something like this:</p>
<pre><code class="language-html"> &lt;div&gt;Hello World&lt;/div&gt;
</code></pre>
<p>The <code>textContent</code> of the div in the browser is now &quot;Hello World&quot;.</p>
<p>If we did not work around this behavior we wouldn't be able  to patch the DOM when two text nodes are next to each other.
We'd have no way of knowing how to find the original, individual strings that we wanted to render.</p>
<p>To get around this here's what we actually end up rendering:</p>
<pre><code class="language-html">&lt;div&gt;Hello &lt;!--ptns--&gt;World&lt;/div&gt;
</code></pre>
<p>Note the new <code>&lt;!--ptns--&gt;</code> comment node. Here's what <code>virtual_dom_rs</code>'s <code>createElement()</code> method ended up doing:</p>
<ol>
<li>Saw the &quot;Hello&quot; virtual text and appended a real Text node into the real DOM <code>&lt;div&gt;</code></li>
<li>Saw the &quot;World&quot; virtual text and saw that the previous element was also a virtual text node</li>
<li>Appended a <code>&lt;!--ptns&gt;</code> real comment element into the <code>&lt;div&gt;</code></li>
<li>Appended a real &quot;World&quot; Text node into the <code>&lt;div&gt;</code></li>
</ol>
<p>If we later wanted to patch the DOM with a new component</p>
<pre><code>let sibling_text_nodes = html! { &lt;div&gt; {&quot;Hello&quot; &quot;NEW_TEXT&quot; } &lt;/div&gt; };
</code></pre>
<p>Our <code>virtual_dom_rs</code> patch function would be able to find the old &quot;World&quot; text node since we've ensured that it
did not get merged in with any other text nodes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
